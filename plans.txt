_____________________________________________________________________________________________
IMPORTANT:
In an effort to ever finish this thing it would probably be best to define some hard limits
on gameplay scope. The game loop should only consist of a single armor slot and a single
weapon slot without a proper inventory that would require me to make an new dedicated UI
screen. Stats should probably also be limited, though maybe there could be certain
consumables that increase them on pickup. No main menu.

TODOS:
Current:
Performance issue: tiles shown
   I believe I'm currently rendering alot of tiles twice. Solution could be to have a normal
   array of dirty tiles that acts as a lookup table so I don't add duplicate indicies to the
   dirty tiles array

Next:
Fix enemies not going back to Wandering when they can no longer see the Player
Move EffectDescriber from Scene to Adventure
Add Scene switching (stairs)
Improve performance
   The number of tiles shown seems to be the main determinant of fps
      Instead of looping through all visible tiles and updating them if they are dirty, make
      a vector of dirty tiles to be looped through directly
   Making a long player-to-mouse-tile pathing trail slows things down hugely. At full zoom
   out the fps drops to ~70, and a full path can drop it further to ~30.
      This is almost certanly the result of a shitty implementation of A*. The only other
      possibility would be reticles somehow taking a long time to render, but making lines
      down long straight halways generates a lot of reticles with hardly any effect on frame
      rate (A* should be faster in this case as it doesn't have so many tiles to search)
Add more creatures
Simple gameplay loop
Slightly better generation

Optional:
Save functionality (maybe in free time)
Better generation (play around with perlin noise and things)
Standardize UI screens
Look into lua

_____________________________________________________________________________________________
UI LAYOUT:
Openable (cover whole screen): Full Character Sheet, Inventory, Level Up Dialogues, Settings
Openable (small screen over map view): Use Ability, Take Items

_____________________________________________________________________________________________
MOVEMENT:
Ensure multiple creatures can't occupy same tile on same turn unless one is flying.

Friendly creatures switch places, otherwise a creature gets blocked when trying to move to a
tile where another exists. Probably disallow npcs moving the player character either, only
player character moving npcs. Otherwise high potential for bad gameplay experience.

Maybe eventually include movement cost modifiers.

_____________________________________________________________________________________________
AI
Necessary:
- Creatures can either be hostile, wary, or passive towards other creatures (including the
  player depending on alignments and threat levels).
- Creatures should retreat when their health percentage is low compared to that of their
  current assailant/would-be victim.
- Creatures should use weapon with highest dps when attacking, potentially modified by a
  'cowardice' stat or something that weights using ranged weapons over melee ones.
- Creatures should be able to use any abilities they have.

Superfluous (maybe add in a later game):
- Have tool-wielding creatures to simulate doing work at workstations, congregate in taverns
  or around campfires in the evening, go to sleep on beds/bedrolls at night.
- Have animals to go to their dens or lairs at different times depending on their circadian
  rhythms.
- Creatures meant to guard things have a chance to fall asleep on the job
- Support for house ownership

_____________________________________________________________________________________________
MODULAR AI
Part 1.) Have a set of core/basic states, like idle, sleeping, attacking, and fleeing.
Part 2.) Have component states that correspond to core states and have different weights.
		 When an entity enters a main state, it immediately rolls one of the component sub-
		 states to engage in. (Also includes some default sub-states like a standing around
		 or wandering state.)
Part 3.) For entity components like inventories, just do flag checks in various functions,
		 so that we just modify possible state behaviors, rather than adding new ones.
